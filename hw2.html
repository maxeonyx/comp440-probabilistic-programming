<!DOCTYPE html>
<script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: 'none',
    tex2jax: {
      inlineMath: [['$','$']],
      displayMath: [['$$','$$']],
      processEnvironments: false
    },
    // show equation numbers
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    'HTML-CSS': {
      imageFont: null
    }
  });
</script>

<html>
    <head>
        
        <title>Homework 2 | </title>
        

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

        <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Homework 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="UBC computer science graduate class on probabilistic programming" />
<meta property="og:description" content="UBC computer science graduate class on probabilistic programming" />
<link rel="canonical" href="https://www.cs.ubc.ca//~fwood/CS532W-539W/homework/2" />
<meta property="og:url" content="https://www.cs.ubc.ca//~fwood/CS532W-539W/homework/2" />
<meta property="og:site_name" content="Probabilistic Programming" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Homework 2" />
<script type="application/ld+json">
{"headline":"Homework 2","description":"UBC computer science graduate class on probabilistic programming","url":"https://www.cs.ubc.ca//~fwood/CS532W-539W/homework/2","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata|PT+Sans">
        <link rel="stylesheet" href="https://unpkg.com/basscss@8.0.2/css/basscss.min.css">

        <link rel="stylesheet" type="text/css" href="/~fwood/CS532W-539W/assets/css/main.css">
        <link rel="stylesheet" type="text/css" href="/~fwood/CS532W-539W/css/github.css">

    </head>

    <body>
        <div class="max-width-4 mx-auto">
            <div class="clearfix">
                <div class="col col-6">
                    <h1>
                        <a href="/~fwood/CS532W-539W/" class="site-title">
                            Probabilistic Programming
                        </a>
                    </h1>
                </div>

                <div class="col col-6">
                    <ul class="list-reset right-align">
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/" class="navigation-item">
                                    home
                                </a>
                            </li>
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/info" class="navigation-item">
                                    info
                                </a>
                            </li>
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/syllabus" class="navigation-item">
                                    syllabus
                                </a>
                            </li>
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/project" class="navigation-item">
                                    project
                                </a>
                            </li>
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/homework" class="navigation-item">
                                    homework
                                </a>
                            </li>
                        
                            <li class="inline-block mr1">
                                <a href="/~fwood/CS532W-539W/resources" class="navigation-item">
                                    resources
                                </a>
                            </li>
                        
                    </ul>
                </div>
            </div>

            <div class="border-top">
                <div class="clearfix">
    <div class="col col-12">
        <h1 id="homework--2">Homework # 2</h1>

<h3 id="learning-goal">Learning Goal</h3>

<p>Learn how to write the first part of an interpreter for the FOPPL.  In particular learn how to manipulate <a href="https://github.com/plai-group/daphne">Daphne compiler</a> abstract syntax tree and graphical model outputs to sample from the <em>prior</em>, i.e. no conditioning (yet).</p>

<h3 id="task">Task</h3>

<p>Write two different FOPPL evaluators, one that evaluates the FOPPL as described in lecture and in the book (Alg. 6), and one that evaluates the FOPPL program via ancestral sampling in the graphical model.  The task is to sample from the <em>prior distribution</em> denoted by the program.  Note that this means that <code class="highlighter-rouge">observe</code> statements should be treated differently.  In particular they can be transformed to <code class="highlighter-rouge">sample</code> statements, ideally in a pre-interpretation transformation pass.  Or they can be ignored.  Also, clearly, the observations themselves, $Y$, should be ignored.</p>

<ul>
  <li>
    <p>Hint 1: you should probably study and complete the pure deterministic language evaluator first as it will be required to evaluate the link expressions when you interpret the program via ancestral sampling in the graphical model.  Test based development is the way to go here.</p>
  </li>
  <li>
    <p>Hint 2: sampling from the prior in the probabilistic programming context means generating samples of the <em>return value</em>.</p>
  </li>
  <li>
    <p>Hint 3: writing your own suite of unit tests, starting with simple fully deterministic programs, then proceeding to models with fixed and known variables names is a good way to test both correctness and coverage.  In other words you may wish to both write tests that do only deterministic computation in the FOPPL and also to write directly in the JSON language</p>
  </li>
</ul>

<h4 id="1">1)</h4>

<p>The referenced (below) support code contains a large (but not necessarily complete) set of tests along with scaffolding to run those tests (and more) (see <code class="highlighter-rouge">run_deterministic_tests</code> and <code class="highlighter-rouge">run_probabilistic_tests</code>).  The first task is to ensure that both of your evaluators pass all of the tests.  We strongly suggest that you expand the set of tests to encompass an increasing amount of functionality, with an eye towards matrix operations in particular.</p>

<h4 id="2">2)</h4>

<p>This program is a standard unit test for probabilistic programming systems, often referred to as a Gaussian unknown mean problem.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [mu (sample (normal 1 (sqrt 5)))
           sigma (sqrt 2)
           lik (normal mu sigma)]
       (observe lik 8)
       (observe lik 9)
       mu)
</code></pre></div></div>

<h4 id="3">3)</h4>

<p>This program specifies a univariate Bayesian linear regression problem.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn observe-data [_ data slope bias]
        (let [xn (first data)
              yn (second data)
              zn (+ (* slope xn) bias)]
          (observe (normal zn 1.0) yn)
          (rest (rest data))))
(let [slope (sample (normal 0.0 10.0))
             bias  (sample (normal 0.0 10.0))
             data (vector 1.0 2.1 2.0 3.9 3.0 5.3
                          4.0 7.7 5.0 10.2 6.0 12.9)]
   (loop 6 data observe-data slope bias)
   (vector slope bias))
</code></pre></div></div>

<h4 id="4">4)</h4>

<p>This program encodes a hidden Markov model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn hmm-step [t states data trans-dists likes]
      (let [z (sample (get trans-dists
                           (last states)))]
        (observe (get likes z)
                 (get data t))
        (append states z)))
(let [data [0.9 0.8 0.7 0.0 -0.025 -5.0 -2.0 -0.1
            0.0 0.13 0.45 6 0.2 0.3 -1 -1]
      trans-dists [(discrete [0.10 0.50 0.40])
                   (discrete [0.20 0.20 0.60])
                   (discrete [0.15 0.15 0.70])]
      likes [(normal -1.0 1.0)
             (normal 1.0 1.0)
             (normal 0.0 1.0)]
      states [(sample (discrete [0.33 0.33 0.34]))]]
  (loop 16 states hmm-step data trans-dists likes))
</code></pre></div></div>

<h4 id="5">5)</h4>

<p>This program corresponds to Bayesian neural network learning.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [weight-prior (normal 0 1)
      W_0 (foreach 10 []
            (foreach 1 [] (sample weight-prior)))
      W_1 (foreach 10 []
            (foreach 10 [] (sample weight-prior)))
      W_2 (foreach 1 []
            (foreach 10 [] (sample weight-prior)))

      b_0 (foreach 10 []
            (foreach 1 [] (sample weight-prior)))
      b_1 (foreach 10 []
            (foreach 1 [] (sample weight-prior)))
      b_2 (foreach 1 []
            (foreach 1 [] (sample weight-prior)))

      x   (mat-transpose [[1] [2] [3] [4] [5]])
      y   [[1] [4] [9] [16] [25]]
      h_0 (mat-tanh (mat-add (mat-mul W_0 x)
                             (mat-repmat b_0 1 5)))
      h_1 (mat-tanh (mat-add (mat-mul W_1 h_0)
                             (mat-repmat b_1 1 5)))
      mu  (mat-transpose
            (mat-tanh (mat-add (mat-mul W_2 h_1)
                               (mat-repmat b_2 1 5))))]
(foreach 5 [y_r y
            mu_r mu]
   (foreach 1 [y_rc y_r
               mu_rc mu_r]
      (observe (normal mu_rc 1) y_rc)))
[W_0 b_0 W_1 b_1])
</code></pre></div></div>

<h3 id="rubric">Rubric</h3>

<p>Submit a <code class="highlighter-rouge">.pdf</code> file to <a href="https://www.gradescope.ca/courses/3339/">gradescope.ca</a> showing your answers for each section.  Provide code snippets that document critical aspects of your implementation sufficient to allow us to quickly determine whether or not you individually completed the assignment. Draw 1000 samples for each of the task programs and report marginal expectations for all return value dimensions, labeled appropriately.  Include histogram plots of the resulting per-dimension sample marginal posterior distribution(s) as well.  This homework is worth 50 points.  Each program that is within tolerance is worth 10 points.  Demonstrably passing all unit tests is worth 10 points.  Include a link to a publicly accessible github repo that allows us to review <em>all</em> of your code.</p>

<h3 id="infrastructure">Infrastructure</h3>

<h4 id="daphne">Daphne</h4>

<p>We are providing you with a compiler called Daphne that implements the desugaring and FOPPL compilation rules discussed in class and described in the book.  Daphne transforms FOPPL programs into <a href="https://www.json.org/json-en.html">JSON</a> datastructures.</p>

<p>These datastructures correspond to two different translations of a FOPPL program
  1) An <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> of the desugared FOPPL program
  2) A graphical model datastructure that results from the compilation process described in the introduction to probabilistic programming book</p>

<p>Clone Daphne from <a href="git@github.com:plai-group/daphne.git">git@github.com:plai-group/daphne.git</a></p>

<h4 id="installation">Installation</h4>

<p>To use Daphne you will need to have both a <a href="https://www.java.com/en/download/">JVM installed</a>
and <a href="https://leiningen.org/">Leiningen</a> installed.</p>

<h4 id="python">Python</h4>

<p>Additionally, helpful Python scaffolding is provided, highlighting in particular primitives implemented in terms of <a href="https://pytorch.org/">PyTorch</a>.</p>

<ul>
  <li><a href="../CS532-HW2.zip">CS532-HW2.zip</a></li>
</ul>

<p>The choice of implementing language is yours; we have provided some bootstrapping for Python but JSON is a widely used in cross-language interoperation.</p>

<p>The set of distributions to recognize and support must include <code class="highlighter-rouge">normal</code>, <code class="highlighter-rouge">uniform-continuous</code>, <code class="highlighter-rouge">beta</code>, and <code class="highlighter-rouge">bernoulli</code> but recognizing that this list may grow may help you in future assignments.</p>

<p><code class="highlighter-rouge">vector</code>, <code class="highlighter-rouge">hashmap</code>, and <code class="highlighter-rouge">list</code> primitive operations must be supported as well.  This means that <code class="highlighter-rouge">first</code>, <code class="highlighter-rouge">rest</code>, <code class="highlighter-rouge">last</code>, <code class="highlighter-rouge">nth</code>, <code class="highlighter-rouge">conj</code>, <code class="highlighter-rouge">cons</code> must be implemented as described in the book.</p>

<p>Primitive mathematical operations must be supported as well, such as <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code>, etc.</p>

<p>A reasonable set of primitives can be had, in Clojure, by
stealing the definition of primitive procedures from Anglican and modifying
it to also count your own implemented primitive procedures.   Note that
in the following <code class="highlighter-rouge">foppl-compiler.primitives</code> would be replaced with
your own namespace.  Thanks to David Tolpin for the Anglican implementation
of this function.</p>

<p>In other words, in Clojure, with the following in your namespace</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(:require [anglican.runtime :refer :all])
(:require [anglican.core :refer :all])
</code></pre></div></div>

<p>and, implementations like this in your own namespaces</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ns foppl-compiler.primitives
  (:require [clojure.core.matrix :as m])
  (:require [anglican.runtime :refer [tanh]]))

  (defn append [&amp; args] (apply conj args))

  (defn mat-mul [&amp; args] (apply m/mmul args))
  (defn mat-add [&amp; args] (apply m/add args))
  (defn mat-transpose [&amp; args] (apply m/transpose args))
  (defn mat-tanh [M] (m/emap tanh M))
  (defn mat-relu [M] (m/emap (fn [x] (if (&gt; x 0) x 0)) M))
  (defn mat-repmat [M r c]
    (let [R (reduce (partial m/join-along 0) (repeat r M))]
      (reduce (partial m/join-along 1) (repeat c R))))
</code></pre></div></div>

<p>In Clojure you can define a “white-list” of primitive procedures
with a function like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(def ^:dynamic *primitive-procedures*
  "primitive procedures, do not exist in CPS form"
  (let [;; higher-order procedures cannot be primitive
        exclude '#{loop
                   map reduce
                   filter keep keep-indexed remove
                   repeatedly
                   every? not-any? some
                   every-pred some-fn
                   comp juxt partial}
        ;; runtime namespaces
        runtime-namespaces '[clojure.core anglican.runtime foppl-compiler.primitives]]
    (set (keep (fn [[k v]]
                 (when (and (not (exclude k))
                            (fn? (var-get v)))
                   k))
               (mapcat ns-publics runtime-namespaces)))))
</code></pre></div></div>

<h3 id="extras">Extras</h3>

<p>What follows is an example list of the kinds of programs that your interpreter should support.  You may wish to establish them as unit tests in your implementation framework.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [x (sample (normal 0 1))]
  x)
</code></pre></div></div>
<hr />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [data (vector 1 2 3)
      a (vector 2)]
  (vector (first (rest (rest data))) a))
</code></pre></div></div>
<hr />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [data (vector 1 2 (sample (normal 1 1)))
      a (conj [] (sample (normal 0 2)))
      b (conj a (sample (normal 0 3)))]
  (observe (normal (second b) 4) (first (rest data)))
  b)
</code></pre></div></div>
<hr />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [x (sample (normal 0 1))]
  (sample (normal x 1)))
</code></pre></div></div>
<hr />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [p (sample (beta 1 1))
      x (sample (beta (exp p) 1))
      d (bernoulli (* x p))]
  (observe d 1)
  p)
</code></pre></div></div>
<hr />
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn observe-data [_ data slope bias]
      (let [xn (first data)
            yn (second data)
            zn (+ (* slope xn) bias)]
        (observe (normal zn 1.0) yn)
        (rest (rest data))))

(let [slope (sample (normal 0.0 10.0))
      bias  (sample (normal 0.0 10.0))
      data (vector 1.0 2.1 2.0 3.9 3.0 5.3
                  4.0 7.7 5.0 10.2 6.0 12.9)]
  (loop 6 data observe-data slope bias)
  (vector slope bias))
</code></pre></div></div>

<ol class="bibliography"></ol>

    </div>
</div>

            </div>
        </div>
    </body>
</html>
